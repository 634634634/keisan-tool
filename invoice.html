<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>納品金額計算</title>
    <style>
        /* スタイルは変更なし */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; color: #333; width: 500px; margin: 20px auto; padding: 0 5px; background-color: #f9f9f9; font-size: 17px; }
        h1, h2, h3 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 8px; }
        /* ★★★ メインタイトルの調整 ★★★ */
        h1 { font-size: 1.4em; margin-top: 0; margin-bottom: 15px; }
        /* ★★★ 伝票内容見出しの調整 ★★★ */
        h2 { font-size: 1.1em; margin-top: 20px; border-bottom-style: dashed; }
        h3 { font-size: 1.2em; margin-top: 20px; border-bottom: 1px solid #ccc; color: #34495e; }
        .container { background-color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; table-layout: fixed; font-size: 1em; }
        /* ★★★ 得意先名（サブタイトル）のスタイル ★★★ */
        .customer-name-subtitle {
            font-size: 1.2em;
            font-weight: bold;
            margin: -10px 0 20px 0;
        }
        th, td { border: 1px solid #ddd; padding: 3px 4px; text-align: left; vertical-align: middle; word-wrap: break-word; } /* ★★★ 左右の余白を調整 ★★★ */
        th { background-color: #f2f2f2; }
        input, select {
            box-sizing: border-box; width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em;
        }
        input { text-align: right; }
        .subtotal, .total-value, .price-cell, .cost-subtotal {
            text-align: right;
            font-size: 0.9em; /* ★★★ 数字のフォントを少し小さく ★★★ */
        }
        .product-name-cell {
            text-align: right;
            font-size: 0.85em; /* ★★★ 商品名のフォントをさらに小さく ★★★ */
        }
        #customerProductsTable .quantity-input { width: 100%; text-align: right; }
        .subtotal-row td { background-color: #f0f8ff; font-weight: bold; }
        .total-label { text-align: right; }
        .total-value { color: #333; }
        .back-link { display: inline-block; margin-bottom: 20px; color: #3498db; text-decoration: none; }
        .back-link:hover { text-decoration: underline; }
        /* ★★★ ヘッダーのスタイル調整 ★★★ */
        th {
            background-color: #f2f2f2;
            text-align: center;
            font-weight: normal; /* ★★★ ヘッダーの太字を解除 ★★★ */
        }
        /* 上段の商品リストの列幅 */
        .col-product-name { width: 45%; } .col-quantity { width: 15%; } .col-price { width: 14%; } .col-sell-price { width: 14%; } .col-department { width: 12%; text-align: center; }
        /* 下段の伝票の列幅 */
        .invoice-col-name { width: 43%; } .invoice-col-qty { width: 7%; } .invoice-col-cost-price { width: 10%; } .invoice-col-cost-sub { width: 15%; } .invoice-col-price { width: 10%; } .invoice-col-sub { width: 15%; }


        /* ★★★ 商品名と数字以外の文字を小さくする ★★★ */
        th, .col-department, .total-label {
            font-size: 0.8em; /* ★★★ フォントサイズをさらに小さく ★★★ */
        }

        /* ★★★ 売価の表示・非表示切り替えスタイル ★★★ */
        .editable-input {
            display: none;
            -moz-appearance: textfield; /* Firefoxで矢印を非表示 */
        }
        /* ★★★ 売価入力欄の矢印を非表示にする (Chrome, Safari, Edge) ★★★ */
        .editable-input[type="number"]::-webkit-outer-spin-button,
        .editable-input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* ★★★ 編集モードのスタイル ★★★ */
        .is-editing .sell-price-input, .is-editing .dept-input { display: block; }
        .is-editing .sell-price-display, .is-editing .dept-display { display: none; }
        .new-product-row .editable-input { display: block; } /* 新規行は常に編集可能 */

        .display-span {
            display: block;
            /* text-align: right; */ /* この行をコメントアウトまたは削除 */
        }

        /* ★★★ マイナス記号(▲)のスタイル ★★★ */
        .minus-symbol {
            font-size: 0.7em; /* フォントを小さく */
            vertical-align: 1px; /* 位置を少し上に調整 */
        }

        /* ★★★ スマホ表示用の調整 ★★★ */
        @media (max-width: 768px) {
            body {
                font-size: 16px; /* スマホでは少し文字を小さく */
                margin-top: 10px;
                margin-bottom: 10px;
            }
            .container {
                padding: 10px; /* スマホではコンテナの余白をさらに詰める */
            }
            h2 {
                margin-top: 25px; /* スマホでは見出しの上の余白を詰める */
            }
        }

        /* ★★★ トースト通知のスタイル ★★★ */
        .toast-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(44, 62, 80, 0.85);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s, top 0.5s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .toast-notification.show { opacity: 1; top: 30px; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">&laquo; 得意先一覧に戻る</a>
        <h1>納品金額計算</h1>
        <p id="customerNameHeader" class="customer-name-subtitle"></p>
        <div id="customerProductsContainer">
            <p>数量を入力すると、下の伝票に自動で反映されます。</p>
            <!-- ★★★ 一時保存ボタンを追加 ★★★ -->
            <div style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button id="clearButton" class="action-button" style="background-color: #e74c3c;">数量をクリア</button>
                <button id="editProductsButton" class="action-button" style="background-color: #2ecc71;">商品を編集</button>
                <button id="addProductButton" class="action-button" style="background-color: #9b59b6; display: none;">商品を追加</button>
                <button id="cancelEditButton" class="action-button" style="background-color: #f39c12; display: none;">キャンセル</button>
            </div>
            <table id="customerProductsTable">
                <thead>
                    <tr>
                        <th class="col-product-name">商品名</th><th class="col-quantity">数量</th><th class="col-price">単価</th><th class="col-sell-price">売価</th><th class="col-department">部門</th>
                    </tr>
                </thead>
                <tbody><tr><td colspan="5" style="text-align: center;">データを読み込んでいます...</td></tr></tbody>
            </table>
        </div>
    </div>
    <div class="container">
        <h2><strong>伝票内容</strong></h2>
        <div id="invoiceContainer"></div>
    </div>

    <script>
        /**
         * アプリケーション全体を管理するオブジェクト
         */
        const App = {
            // 設定値
            config: {
                gasWebAppUrl: 'https://script.google.com/macros/s/AKfycbyxShi2b0-fiyGXRfK2Ro0PiHHOJoPg5VdUPXXFTJtxizsZvMX5qsybwbbBcIwOQLLzmg/exec',
                selectors: {
                    backLink: '.back-link',
                    productsTableBody: '#customerProductsTable tbody',
                    invoiceContainer: '#invoiceContainer',
                    customerNameHeader: '#customerNameHeader',
                    clearButton: '#clearButton',
                    editProductsButton: '#editProductsButton',
                    addProductButton: '#addProductButton',
                    quantityInput: '.quantity-input',
                    cancelEditButton: '#cancelEditButton',
                }
            },
            // 定数
            constants: {
                EDIT_MODE_CLASS: 'is-editing',
                NEW_PRODUCT_ROW_CLASS: 'new-product-row',
                UNKNOWN_DEPT_ID: 'unknown'
            },
            // アプリケーションの状態
            state: {
                isDirty: false,
                customerId: null,
                customerName: '',
                products: [],
                departments: [],
            },
            // DOM要素
            elements: {},

            /**
             * アプリケーションの初期化
             */
            async init() {
                this.cacheDOMElements();
                this.injectStyles();
                this.setupLinks();

                const params = new URLSearchParams(window.location.search);
                this.state.customerId = parseInt(params.get('customerId'), 10);

                if (!this.state.customerId) {
                    this.ui.showError('有効な得意先が選択されていません。');
                    return;
                }

                const masterData = await this.api.fetchMasterData();
                this.state.products = masterData.filter(row => row['得意先コード'] === this.state.customerId);

                if (this.state.products.length === 0) {
                    this.ui.showError('指定された得意先のデータが見つかりません。');
                    return;
                }

                this.state.customerName = this.state.products[0]['得意先名'];
                this.state.departments = this.util.createDepartmentList(masterData);

                this.elements.customerNameHeader.textContent = this.state.customerName;

                this.ui.displayCustomerProducts();
                this.ui.generateInvoices();
                this.events.init();
            },

            /**
             * 頻繁に使うDOM要素をキャッシュ
             */
            cacheDOMElements() {
                for (const key in this.config.selectors) {
                    this.elements[key] = document.querySelector(this.config.selectors[key]);
                }
            },

            /**
             * 動的なスタイルを注入
             */
            injectStyles() {
                const style = document.createElement('style');
                style.textContent = `.action-button { padding: 8px 12px; border: none; color: white; border-radius: 4px; cursor: pointer; }`;
                document.head.appendChild(style);
            },

            /**
             * リンクにキャッシュ対策を追加
             */
            setupLinks() {
                if (this.elements.backLink) {
                    this.elements.backLink.href = `index.html?_=${new Date().getTime()}`;
                }
            },

            /**
             * 状態の変更をセット
             * @param {boolean} dirty - 変更があったかどうか
             */
            setDirty(dirty) {
                this.state.isDirty = dirty;
            },

            // --- API通信関連 ---
            api: {
                async fetchMasterData() {
                    try {
                        const url = `${App.config.gasWebAppUrl}?_=${new Date().getTime()}`;
                        const response = await fetch(url);
                        if (!response.ok) throw new Error(`Network response was not ok. Status: ${response.status}`);
                        const data = await response.json();
                        if (data.error) throw new Error(data.error);
                        return data;
                    } catch (error) {
                        console.error('Error fetching master data from GAS:', error);
                        return [];
                    }
                },
                async postData(payload) {
                    const response = await fetch(App.config.gasWebAppUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'text/plain;charset=utf-8' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();
                    if (result.status === 'error') throw new Error(result.message);
                    return result;
                }
            },

            // --- イベント関連 ---
            events: {
                init() {
                    App.elements.clearButton.addEventListener('click', this.handleClearQuantities);
                    App.elements.editProductsButton.addEventListener('click', () => this.handleToggleEditMode());
                    App.elements.addProductButton.addEventListener('click', this.handleAddNewProduct);
                    App.elements.cancelEditButton.addEventListener('click', () => this.handleCancelEdit());
                    App.elements.productsTableBody.addEventListener('input', this.handleTableInput);
                    App.elements.productsTableBody.addEventListener('focusin', this.handleFocusIn);
                    App.elements.productsTableBody.addEventListener('keydown', this.handleKeyDown);
                    document.addEventListener('visibilitychange', this.handleVisibilityChange); // ★★★ 自動保存イベントを追加
                },

                async handleClearQuantities() {
                    if (!confirm('保存されている数量をすべてクリアします。よろしいですか？')) return;

                    const updates = [];
                    App.elements.productsTableBody.querySelectorAll('tr[data-product-id]').forEach(row => {
                        const productId = row.dataset.productId;
                        const originalProduct = App.state.products.find(p => p['商品コード'] == productId);
                        const originalQty = (originalProduct && originalProduct['数量']) ? parseFloat(originalProduct['数量']) : 0;
                        const inputQtyText = row.querySelector(App.config.selectors.quantityInput).value;
                        const inputQty = inputQtyText !== '' ? parseFloat(inputQtyText) : 0;

                        if (!isNaN(originalQty) && originalQty !== 0 || !isNaN(inputQty) && inputQty !== 0) {
                            updates.push({ '商品コード': parseInt(productId, 10), '数量': 0 });
                        }
                    });

                    if (updates.length === 0) {
                        App.ui.showToast('クリア対象の商品がありません。');
                        return;
                    }

                    App.ui.toggleButtonState(App.elements.clearButton, true, 'クリア中...');
                    try {
                        await App.api.postData({ updates });
                        App.elements.productsTableBody.querySelectorAll(App.config.selectors.quantityInput).forEach(input => {
                            input.value = '';
                        });
                        // ★★★ stateの数量もクリアして、isDirtyの判定を正しくする ★★★
                        updates.forEach(update => {
                            const product = App.state.products.find(p => p['商品コード'] === update['商品コード']);
                            if (product) product['数量'] = 0;
                        });

                        App.ui.generateInvoices();
                        App.setDirty(false);
                        App.ui.showToast('数量をクリアしました。');
                    } catch (error) {
                        alert('数量のクリア中にエラーが発生しました。\n' + error.message);
                    } finally {
                        App.ui.toggleButtonState(App.elements.clearButton, false, '数量をクリア');
                    }
                },

                async handleToggleEditMode() {
                    const isEditing = App.elements.productsTableBody.classList.contains(App.constants.EDIT_MODE_CLASS);
                    if (isEditing) {
                        const wasSaved = await App.events.handleSaveProducts();
                        if (wasSaved) {
                            App.setDirty(false);
                            App.ui.toggleEditMode(false);
                            App.ui.showToast('保存しました。ページを更新します...', 2000);
                            setTimeout(() => window.location.reload(), 2000);
                        }
                    } else {
                        App.setDirty(true);
                        App.ui.toggleEditMode(true);
                    }
                },

                async handleSaveProducts() {
                    const updates = [];
                    const additions = [];
                    App.elements.productsTableBody.querySelectorAll('tr[data-product-id]').forEach(row => {
                        const productId = row.dataset.productId;
                        const isNew = row.classList.contains(App.constants.NEW_PRODUCT_ROW_CLASS);
                        const newName = row.querySelector('.name-input').value;
                        const newUnitPrice = row.querySelector('.unit-price-input').value;
                        const newSellPrice = row.querySelector('.sell-price-input').value;
                        const deptSelect = row.querySelector('.dept-input');
                        const newDeptCode = deptSelect.value;
                        const newDeptName = deptSelect.selectedIndex > -1 ? deptSelect.options[deptSelect.selectedIndex].text : '';

                        if (isNew) {
                            if (newName) {
                                additions.push({
                                    '得意先コード': App.state.customerId, '得意先名': App.state.customerName, '商品名': newName,
                                    '単価': newUnitPrice !== '' ? parseFloat(newUnitPrice) : null,
                                    '売価': newSellPrice !== '' ? parseFloat(newSellPrice) : null,
                                    '部門コード': newDeptCode, '部門': newDeptName
                                });
                            }
                        } else {
                            const originalProduct = App.state.products.find(p => p['商品コード'] == productId);
                            if (!originalProduct) return;
                            const changedData = { '商品コード': parseInt(productId, 10) };
                            let hasChanged = false;
                            const originalSellPrice = originalProduct['売価'] || null;
                            const parsedNewSellPrice = newSellPrice !== '' ? parseFloat(newSellPrice) : null;
                            if (parsedNewSellPrice !== originalSellPrice) { changedData['売価'] = parsedNewSellPrice; hasChanged = true; }
                            const originalDeptCode = originalProduct['部門コード'] || null;
                            if (newDeptCode != (originalDeptCode ?? '')) { changedData['部門コード'] = newDeptCode; changedData['部門'] = newDeptName; hasChanged = true; }

                            if (hasChanged) updates.push(changedData);
                        }
                    });

                    if (updates.length === 0 && additions.length === 0) {
                        App.ui.showToast('変更された項目はありません。');
                        return false;
                    }
                    if (!confirm(`${updates.length}件の更新、${additions.length}件の新規追加を保存します。よろしいですか？`)) return false;

                    const button = App.elements.editProductsButton;
                    App.ui.toggleButtonState(button, true, '保存中...');
                    try {
                        await App.api.postData({ updates, additions });
                        return true;
                    } catch (error) {
                        alert('保存中にエラーが発生しました。\n' + error.message);
                        return false;
                    } finally {
                        App.ui.toggleButtonState(button, false, '変更を保存');
                    }
                },

                handleCancelEdit() {
                    if (confirm('編集中の内容は破棄されます。よろしいですか？')) {
                        App.ui.toggleEditMode(false);
                        App.ui.displayCustomerProducts(); // テーブルを元の状態に再描画
                        App.ui.generateInvoices(); // 伝票も再描画
                        App.setDirty(false); // 変更フラグをリセット
                        App.ui.showToast('編集をキャンセルしました。');
                    }
                },

                handleAddNewProduct() {
                    App.ui.appendNewProductRow();
                    App.setDirty(true);
                },

                handleTableInput() {
                    App.ui.generateInvoices();
                    App.setDirty(true);
                },

                handleFocusIn(e) {
                    if (e.target.classList.contains('quantity-input')) {
                        e.target.select();
                    }
                },

                handleKeyDown(e) {
                    if (e.key === 'Enter' && e.target.classList.contains('quantity-input')) {
                        e.preventDefault();
                        const allInputs = Array.from(App.elements.productsTableBody.querySelectorAll(App.config.selectors.quantityInput));
                        const currentIndex = allInputs.indexOf(e.target);
                        const nextIndex = currentIndex + 1;
                        if (nextIndex < allInputs.length) {
                            allInputs[nextIndex].focus();
                            allInputs[nextIndex].select();
                        } else {
                            e.target.blur();
                        }
                    }
                },

                handleVisibilityChange() {
                    // ページが非表示になり、かつ変更がある場合に自動保存を実行
                    if (document.visibilityState === 'hidden' && App.state.isDirty) {
                        const updates = [];
                        App.elements.productsTableBody.querySelectorAll('tr[data-product-id]').forEach(row => {
                            const productId = row.dataset.productId;
                            if (productId.startsWith('new_')) return;

                            const quantityInput = row.querySelector(App.config.selectors.quantityInput).value;
                            const quantity = parseFloat(quantityInput);
                            if (quantityInput !== '' && !isNaN(quantity)) {
                                updates.push({ '商品コード': parseInt(productId, 10), '数量': quantity });
                            }
                        });

                        if (updates.length > 0) {
                            // ページを離れる直前のデータ送信のため、完了を待たない
                            try {
                                App.api.postData({ updates });
                                App.setDirty(false); // 送信試行後は変更フラグをリセット
                            } catch (error) {
                                // このエラーはユーザーには通知しない（ページ離脱中のため）
                                console.error('Auto-save failed:', error);
                            }
                        }
                    }
                }
            },

            // --- UI関連 ---
            ui: {
                showError(message) {
                    document.body.innerHTML = `<div class="container"><h1>エラー</h1><p>${message}</p><a href="index.html">得意先一覧に戻ってください。</a></div>`;
                },

                showToast(message, duration = 2000) {
                    const toast = document.createElement('div');
                    toast.className = 'toast-notification';
                    toast.textContent = message;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.classList.add('show'), 100);
                    setTimeout(() => {
                        toast.classList.remove('show');
                        toast.addEventListener('transitionend', () => toast.remove());
                    }, duration);
                },

                toggleButtonState(button, isDisabled, text) {
                    button.disabled = isDisabled;
                    button.textContent = text;
                },

                toggleEditMode(isEditing) {
                    // App.elements.productsTableBody.classList.remove('is-editing'); // 既存のクラスを削除
                    
                    if (isEditing) {
                        App.elements.productsTableBody.classList.add('is-editing'); // 'is-editing' を追加
                        this.toggleButtonState(App.elements.editProductsButton, false, '変更を保存');
                        App.elements.editProductsButton.style.backgroundColor = '#16a085';
                        App.elements.addProductButton.style.display = 'inline-block';
                        App.elements.cancelEditButton.style.display = 'inline-block';
                    } else {
                        this.toggleButtonState(App.elements.editProductsButton, false, '商品を編集');
                        App.elements.editProductsButton.style.backgroundColor = '#2ecc71';
                        App.elements.productsTableBody.classList.remove('is-editing'); // 'is-editing' を削除
                        App.elements.addProductButton.style.display = 'none';
                        App.elements.cancelEditButton.style.display = 'none';
                    }
                },

                displayCustomerProducts() {
                    const { productsTableBody } = App.elements;
                    productsTableBody.innerHTML = '';
                    if (App.state.products.length > 0) {
                        App.state.products.forEach(product => {
                            const row = this.createProductRow(product);
                            productsTableBody.appendChild(row);
                        });
                    } else {
                        productsTableBody.innerHTML = '<tr><td colspan="5">この得意先に登録されている商品はありません。</td></tr>';
                    }
                },

                createProductRow(product) {
                    const row = document.createElement('tr');
                    row.dataset.productId = product['商品コード'];
                    const unitPrice = product['単価'] || '';
                    const sellPrice = product['売価'] || '';
                    const deptSelect = document.createElement('select');
                    deptSelect.className = 'editable-input dept-input';

                    // ★★★ 先頭に空白の選択肢を追加 ★★★
                    const blankOption = document.createElement('option');
                    blankOption.value = '';
                    blankOption.textContent = ''; // 表示は空白
                    deptSelect.appendChild(blankOption);

                    App.state.departments.forEach(dept => {
                        const option = document.createElement('option');
                        option.value = dept.id;
                        option.textContent = dept.name;
                        if (dept.id == product['部門コード']) option.selected = true; // 型が違う可能性を考慮して == で比較
                        deptSelect.appendChild(option);
                    });
                    row.innerHTML = `<td class="product-name-cell"><span class="display-span name-display">${product['商品名']}</span><input type="text" class="editable-input name-input" value="${product['商品名']}"></td>
                                     <td><input type="number" class="quantity-input" placeholder="0" value="${product['数量'] || ''}"></td>
                                     <td class="price-cell"><span class="display-span unit-price-display">${unitPrice ? unitPrice.toLocaleString() : ''}</span><input type="number" class="editable-input unit-price-input" value="${unitPrice}"></td>
                                     <td class="price-cell"><span class="display-span sell-price-display">${sellPrice ? sellPrice.toLocaleString() : ''}</span><input type="number" class="editable-input sell-price-input" value="${sellPrice}"></td>
                                     <td class="col-department"><span class="display-span dept-display">${product['部門'] || ''}</span></td>`;
                    row.cells[4].appendChild(deptSelect);
                    return row;
                },

                appendNewProductRow() {
                    // ★★★ 新規行のデフォルト部門を空白にする ★★★
                    const newProduct = { '商品コード': `new_${Date.now()}`, '商品名': '', '単価': '', '売価': '', '部門コード': '' };
                    const newRow = this.createProductRow(newProduct);
                    newRow.classList.add(App.constants.NEW_PRODUCT_ROW_CLASS, App.constants.EDIT_MODE_CLASS);
                    App.elements.productsTableBody.appendChild(newRow);
                    newRow.querySelector('.name-input').focus();
                },

                generateInvoices() {
                    const allItems = this.collectAllItems();
                    const groupedByDept = this.groupItemsByDepartment(allItems);
                    this.renderInvoices(groupedByDept);
                },

                collectAllItems() {
                    const items = [];
                    App.elements.productsTableBody.querySelectorAll('tr[data-product-id]').forEach(row => {
                        const quantity = parseFloat(row.querySelector(App.config.selectors.quantityInput).value);
                        const productId = row.dataset.productId;
                        const isNew = row.classList.contains(App.constants.NEW_PRODUCT_ROW_CLASS);
                        if (quantity !== 0 && !isNaN(quantity) && !isNew) {
                            const numericProductId = parseInt(productId, 10);
                            const productData = App.state.products.find(p => p['商品コード'] === numericProductId);
                            if (productData) {
                                const itemData = { ...productData, quantity };
                                const currentUnitPrice = parseFloat(row.querySelector('.unit-price-input').value);
                                const currentSellPrice = parseFloat(row.querySelector('.sell-price-input').value);
                                const deptSelect = row.querySelector('.dept-input');
                                const currentDeptCode = deptSelect.value;
                                const currentDeptName = deptSelect.selectedIndex > -1 ? deptSelect.options[deptSelect.selectedIndex].text : (productData['部門'] || '');
                                if (!isNaN(currentUnitPrice)) itemData['単価'] = currentUnitPrice;
                                if (!isNaN(currentSellPrice)) itemData['売価'] = currentSellPrice;
                                itemData['部門コード'] = currentDeptCode;
                                itemData['部門'] = currentDeptName;
                                items.push(itemData);
                            }
                        }
                    });
                    return items;
                },

                groupItemsByDepartment(items) {
                    return items.reduce((grouped, item) => {
                        const deptId = item['部門コード'] || App.constants.UNKNOWN_DEPT_ID;
                        if (!grouped[deptId]) {
                            grouped[deptId] = { name: item['部門'], items: [] };
                        }
                        grouped[deptId].items.push(item);
                        return grouped;
                    }, {});
                },

                renderInvoices(groupedData) {
                    App.elements.invoiceContainer.innerHTML = '';
                    let grandTotalCost = 0;
                    for (const deptId in groupedData) {
                        const dept = groupedData[deptId];
                        const departmentHeader = document.createElement('h3');
                        departmentHeader.textContent = dept.name;
                        App.elements.invoiceContainer.appendChild(departmentHeader);
                        const table = document.createElement('table');
                        table.innerHTML = `<thead><tr><th class="invoice-col-name">品名</th><th class="invoice-col-qty">数量</th><th class="invoice-col-cost-price">原単価</th><th class="invoice-col-cost-sub">原価金額</th><th class="invoice-col-price">売単価</th><th class="invoice-col-sub">売価金額</th></tr></thead>`;
                        const tbody = document.createElement('tbody');
                        let itemCounter = 0;
                        let runningSubtotal = 0;
                        let runningCostSubtotal = 0;
                        dept.items.forEach((item, index) => {
                            itemCounter++;
                            const itemSubtotal = item.quantity * item['売価'];
                            const costSubtotal = item.quantity * (item['単価'] || 0);
                            runningSubtotal += itemSubtotal;
                            runningCostSubtotal += costSubtotal;
                            grandTotalCost += costSubtotal;
                            const row = document.createElement('tr');
                            const displayCost = item['単価'] ? App.util.formatNumber(item['単価']) : '';
                            const displayCostSubtotal = (item['単価'] && item['単価'] > 0) ? App.util.formatNumber(costSubtotal) : '';
                            const displaySellPrice = (item['売価'] && item['売価'] > 0) ? App.util.formatNumber(item['売価']) : '';
                            row.appendChild(App.util.createCell(item['商品名'], 'product-name-cell'));
                            row.appendChild(App.util.createCell(App.util.formatNumber(item.quantity), 'price-cell'));
                            row.appendChild(App.util.createCell(displayCost, 'price-cell'));
                            row.appendChild(App.util.createCell(displayCostSubtotal, 'cost-subtotal'));
                            row.appendChild(App.util.createCell(displaySellPrice, 'price-cell'));
                            row.appendChild(App.util.createCell(App.util.formatNumber(itemSubtotal), 'subtotal'));
                            tbody.appendChild(row);
                            const isLastItem = index === dept.items.length - 1;
                            if (itemCounter % 6 === 0 || isLastItem) {
                                const subtotalRow = document.createElement('tr');
                                subtotalRow.className = 'subtotal-row';
                                const labelCell1 = App.util.createCell('合計', 'total-label');
                                labelCell1.colSpan = 3;
                                subtotalRow.appendChild(labelCell1);
                                subtotalRow.appendChild(App.util.createCell(App.util.formatNumber(runningCostSubtotal), 'total-value'));
                                subtotalRow.appendChild(App.util.createCell('合計', 'total-label'));
                                subtotalRow.appendChild(App.util.createCell(App.util.formatNumber(runningSubtotal), 'total-value'));
                                tbody.appendChild(subtotalRow);
                                runningSubtotal = 0;
                                runningCostSubtotal = 0;
                            }
                        });
                        table.appendChild(tbody);
                        App.elements.invoiceContainer.appendChild(table);
                    }
                    if (Object.keys(groupedData).length > 0) {
                        const grandTotalHeader = document.createElement('h3');
                        grandTotalHeader.textContent = '総合計';
                        grandTotalHeader.style.cssText = 'border-top: 2px solid #3498db; padding-top: 15px; margin-top: 30px;';
                        const table = document.createElement('table');
                        const tbody = document.createElement('tbody');
                        const totalRow = document.createElement('tr');
                        totalRow.className = 'subtotal-row';
                        totalRow.innerHTML = `<td class="total-label" colspan="5">原価金額 総合計</td><td class="total-value">${App.util.formatNumber(grandTotalCost)}</td>`;
                        tbody.appendChild(totalRow);
                        table.appendChild(tbody);
                        App.elements.invoiceContainer.appendChild(grandTotalHeader);
                        App.elements.invoiceContainer.appendChild(table);
                    }
                }
            },

            // --- ユーティリティ関数 ---
            util: {
                createCell(text, className) {
                    const cell = document.createElement('td');
                    cell.innerHTML = text;
                    if (className) cell.className = className;
                    return cell;
                },

                formatNumber(num) {
                    if (typeof num !== 'number' || isNaN(num)) return '';
                    if (num < 0) {
                        return `<span class="minus-symbol">▲</span>${Math.abs(num).toLocaleString()}`;
                    }
                    return num.toLocaleString();
                },

                createDepartmentList(masterData) {
                    const deptMap = new Map();
                    masterData.forEach(row => {
                        if (row['部門コード'] && !deptMap.has(row['部門コード'])) {
                            deptMap.set(row['部門コード'], row['部門']);
                        }
                    });
                    return Array.from(deptMap, ([id, name]) => ({ id, name }));
                }
            }
        };

        document.addEventListener('DOMContentLoaded', () => App.init());
    </script>
</body>
</html>
