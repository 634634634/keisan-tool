<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <!-- ★★★ セキュリティ対策: Content Security Policy (CSP) を追加 ★★★ -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' https://script.google.com https://script.googleusercontent.com; object-src 'none'; base-uri 'self'; form-action 'self';">
    <title>納品金額計算</title>
    <style>
        /* スタイルは変更なし */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; color: #333; width: 500px; margin: 20px auto; padding: 0 5px; background-color: #f9f9f9; font-size: 17px; }
        h1, h2, h3 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 8px; }
        /* ★★★ メインタイトルの調整 ★★★ */
        h1 { font-size: 1.4em; margin-top: 0; margin-bottom: 15px; }
        /* ★★★ 伝票内容見出しの調整 ★★★ */
        h2 { font-size: 1.1em; margin-top: 20px; border-bottom-style: dashed; }
        h3 { font-size: 1.2em; margin-top: 20px; border-bottom: 1px solid #ccc; color: #34495e; }
        .container { background-color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; table-layout: fixed; font-size: 1em; }
        /* ★★★ 得意先名（サブタイトル）のスタイル ★★★ */
        .customer-name-subtitle {
            font-size: 1.2em;
            font-weight: bold;
            margin: -10px 0 20px 0;
        }
        th, td { border: 1px solid #ddd; padding: 3px 4px; text-align: left; vertical-align: middle; word-wrap: break-word; } /* ★★★ 左右の余白を調整 ★★★ */
        th { background-color: #f2f2f2; }
        input, select {
            box-sizing: border-box; width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em;
        }
        input { text-align: right; }
        .subtotal, .total-value, .price-cell, .cost-subtotal {
            text-align: right;
            font-size: 0.9em; /* ★★★ 数字のフォントを少し小さく ★★★ */
        }
        .product-name-cell {
            text-align: right;
            font-size: 0.85em; /* ★★★ 商品名のフォントをさらに小さく ★★★ */
        }
        #customerProductsTable .quantity-input { width: 100%; text-align: right; }
        .subtotal-row td { background-color: #f0f8ff; font-weight: bold; }
        .total-label { text-align: right; }
        .total-value { color: #333; }
        .back-link { display: inline-block; margin-bottom: 20px; color: #3498db; text-decoration: none; }
        .back-link:hover { text-decoration: underline; }
        /* ★★★ ヘッダーのスタイル調整 ★★★ */
        th {
            background-color: #f2f2f2;
            text-align: center;
            font-weight: normal; /* ★★★ ヘッダーの太字を解除 ★★★ */
        }
        /* 上段の商品リストの列幅 */
        .col-product-name { width: 45%; } .col-quantity { width: 15%; } .col-price { width: 14%; } .col-sell-price { width: 14%; } .col-department { width: 12%; text-align: center; }
        /* 下段の伝票の列幅 */
        .invoice-col-name { width: 43%; } .invoice-col-qty { width: 7%; } .invoice-col-cost-price { width: 10%; } .invoice-col-cost-sub { width: 15%; } .invoice-col-price { width: 10%; } .invoice-col-sub { width: 15%; }


        /* ★★★ 商品名と数字以外の文字を小さくする ★★★ */
        th, .col-department, .total-label {
            font-size: 0.8em; /* ★★★ フォントサイズをさらに小さく ★★★ */
        }

        /* ★★★ 売価の表示・非表示切り替えスタイル ★★★ */
        .editable-input {
            display: none;
            -moz-appearance: textfield; /* Firefoxで矢印を非表示 */
        }
        /* ★★★ 売価入力欄の矢印を非表示にする (Chrome, Safari, Edge) ★★★ */
        .editable-input[type="number"]::-webkit-outer-spin-button,
        .editable-input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* ★★★ 編集モードのスタイル ★★★ */
        .is-editing .sell-price-input, .is-editing .dept-input { display: block; }
        .is-editing .sell-price-display, .is-editing .dept-display { display: none; }
        .new-product-row .editable-input { display: block; } /* 新規行は常に編集可能 */

        .display-span {
            display: block;
            /* text-align: right; */ /* この行をコメントアウトまたは削除 */
        }

        /* ★★★ マイナス記号(▲)のスタイル ★★★ */
        .minus-symbol {
            font-size: 0.7em; /* フォントを小さく */
            vertical-align: 1px; /* 位置を少し上に調整 */
        }

        /* ★★★ スマホ表示用の調整 ★★★ */
        @media (max-width: 768px) {
            body {
                font-size: 16px; /* スマホでは少し文字を小さく */
                margin-top: 10px;
                margin-bottom: 10px;
            }
            .container {
                padding: 10px; /* スマホではコンテナの余白をさらに詰める */
            }
            h2 {
                margin-top: 25px; /* スマホでは見出しの上の余白を詰める */
            }
        }

        /* ★★★ トースト通知のスタイル ★★★ */
        .toast-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(44, 62, 80, 0.85);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s, top 0.5s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .toast-notification.show { opacity: 1; top: 30px; }

        /* ★★★ カスタムフォーマット用の列幅調整（売価なしパターン） ★★★ */
        .invoice-table.no-sell .invoice-col-name { width: 55%; }
        .invoice-table.no-sell .invoice-col-qty { width: 10%; }
        .invoice-table.no-sell .invoice-col-cost-price { width: 15%; }
        .invoice-table.no-sell .invoice-col-cost-sub { width: 20%; }

        /* ★★★ リファクタリング: JSからスタイルを分離 ★★★ */
        .grand-total-header { border-top: 2px solid #3498db; padding-top: 15px; margin-top: 30px; }
        .grand-total-row { font-size: 1.1em; }
        .subtotal-cell-item { padding: 2px 0; }
        .subtotal-cell-divider { border-bottom: 1px solid #ccc; }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">&laquo; 得意先一覧に戻る</a>
        <h1>納品金額計算</h1>
        <p id="customerNameHeader" class="customer-name-subtitle"></p>
        <div id="customerProductsContainer">
            <p>数量を入力すると、下の伝票に自動で反映されます。</p>
            <!-- ★★★ 一時保存ボタンを追加 ★★★ -->
            <div style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button id="clearButton" class="action-button" style="background-color: #e74c3c;">数量をクリア</button>
                <button id="editProductsButton" class="action-button" style="background-color: #2ecc71;">商品を編集</button>
                <button id="addProductButton" class="action-button" style="background-color: #9b59b6; display: none;">商品を追加</button>
                <button id="cancelEditButton" class="action-button" style="background-color: #f39c12; display: none;">キャンセル</button>
            </div>
            <table id="customerProductsTable">
                <thead>
                    <tr>
                        <th class="col-product-name">商品名</th><th class="col-quantity">数量</th><th class="col-price">単価</th><th class="col-sell-price">売価</th><th class="col-department">部門</th>
                    </tr>
                </thead>
                <tbody><tr><td colspan="5" style="text-align: center;">データを読み込んでいます...</td></tr></tbody>
            </table>
        </div>
    </div>
    <div class="container">
        <h2><strong>伝票内容</strong></h2>
        <div id="invoiceContainer"></div>
    </div>

    <script>
        /**
         * アプリケーション全体を管理するオブジェクト
         */
        const App = {
            // 設定値
            config: {
                gasWebAppUrl: 'https://script.google.com/macros/s/AKfycbzKasZn6oHcORLfCLeT_H_fsHVeFjRTBHZfgQqYZpFROp900oJI_9dKv_dh800hovqeBg/exec',
                selectors: {
                    backLink: '.back-link',
                    productsTableBody: '#customerProductsTable tbody',
                    invoiceContainer: '#invoiceContainer',
                    customerNameHeader: '#customerNameHeader',
                    clearButton: '#clearButton',
                    editProductsButton: '#editProductsButton',
                    addProductButton: '#addProductButton',
                    quantityInput: '.quantity-input',
                    cancelEditButton: '#cancelEditButton',
                    nameInput: '.name-input',
                    unitPriceInput: '.unit-price-input',
                    sellPriceInput: '.sell-price-input',
                    deptInput: '.dept-input'
                }
            },
            // ★★★ アプリケーション設定（マジックナンバーの排除） ★★★
            settings: {
                itemsPerInvoicePage: 6, // 伝票の小計を入れる行数
                toastDuration: 2000,
                toastErrorDuration: 4000,
                backupExpirationMs: 60000, // バックアップの有効期限（ミリ秒）
                // ★★★ 伝票フォーマット設定 ★★★
                formats: {
                    default: {
                        rowsPerPage: 6,
                        showCost: true,
                        showSell: true,
                        showTax: false,
                        taxRate: 0.08, // デフォルト税率 8%
                        taxRounding: 'floor' // 端数処理 (floor:切り捨て, ceil:切り上げ, round:四捨五入)
                    },
                    // ★★★ 特定の得意先用の設定（ここにIDを指定） ★★★
                    special: {
                        // customerIds: [], // スプレッドシートの「フォーマット」列で "special" と指定することで適用されます
                        rowsPerPage: 5,
                        showCost: true, showSell: false, showTax: true,
                        taxRate: 0.08, // 特別税率 8%
                        taxRounding: 'floor' // 端数処理 (floor:切り捨て, ceil:切り上げ, round:四捨五入)
                    }
                }
            },
            // 定数
            constants: {
                EDIT_MODE_CLASS: 'is-editing',
                NEW_PRODUCT_ROW_CLASS: 'new-product-row',
                UNKNOWN_DEPT_ID: 'unknown',
                // ★★★ クラス名の定数化 ★★★
                CLASSES: {
                    PRODUCT_NAME_CELL: 'product-name-cell',
                    PRICE_CELL: 'price-cell',
                        COST_SUBTOTAL_CELL: 'cost-subtotal',
                        SUBTOTAL_CELL: 'subtotal',
                    DISPLAY_SPAN: 'display-span',
                        EDITABLE_INPUT: 'editable-input',
                        SUBTOTAL_ROW: 'subtotal-row',
                        TOTAL_LABEL: 'total-label',
                        TOTAL_VALUE: 'total-value'
                }
            },
            // アプリケーションの状態
            state: {
                isDirty: false,
                customerId: null,
                customerName: '',
                products: [],
                departments: [],
            },
            // ★★★ 状態を変更するための専用関数（ミューテーション） ★★★
            mutations: {
                setInitialData(state, { customerId, products, departments }) {
                    // ★★★ 商品コードがない場合は商品名をIDとして使用し、全て文字列として扱うよう正規化 ★★★
                    const normalizedProducts = products.map(p => {
                        const code = (p['商品コード'] != null && p['商品コード'] !== '') ? String(p['商品コード']) : p['商品名'];
                        const deptCode = (p['部門コード'] != null && p['部門コード'] !== '') ? String(p['部門コード']) : (p['部門'] || App.constants.UNKNOWN_DEPT_ID);
                        return { ...p, '商品コード': code, '部門コード': deptCode };
                    });

                    // ★★★ GASの反映遅延対策: 直近のローカルバックアップがあればマージする ★★★
                    const backupKey = `backup_${customerId}`;
                    const backupJson = sessionStorage.getItem(backupKey);
                    if (backupJson) {
                        try {
                            const backup = JSON.parse(backupJson);
                            // 60秒以内のバックアップなら有効とみなす
                            if (Date.now() - backup.timestamp < App.settings.backupExpirationMs) {
                                backup.updates.forEach(update => {
                                    // 正規化済みのデータに対して検索（文字列同士の比較になるので安全）
                                    const product = normalizedProducts.find(p => p['商品コード'] === String(update['商品コード']));
                                    if (product) {
                                        if (update['数量'] !== undefined) product['数量'] = update['数量'];
                                        if (update['売価'] !== undefined) product['売価'] = update['売価'];
                                        if (update['部門コード'] !== undefined) {
                                            product['部門コード'] = update['部門コード'];
                                            product['部門'] = update['部門'];
                                        }
                                    }
                                });
                            } else {
                                sessionStorage.removeItem(backupKey);
                            }
                        } catch (e) {
                            console.error('Backup restore failed:', e);
                        }
                    }

                    state.customerId = customerId;
                    state.products = normalizedProducts;
                    state.customerName = normalizedProducts[0]?.['得意先名'] || '';
                    // ★★★ 部門コードがない場合は部門名をIDとして使用する ★★★
                    state.departments = departments
                        .filter(dept => dept.name && String(dept.name).trim() !== '')
                        .map(dept => ({ ...dept, id: (dept.id != null && dept.id !== '') ? String(dept.id) : dept.name }));
                },
                setDirty(state, isDirty) {
                    state.isDirty = isDirty;
                }
            },
            // DOM要素
            elements: {},

            /**
             * アプリケーションの初期化
             */
            async init() {
                this.cacheDOMElements();
                this.injectStyles();
                this.setupLinks();

                const params = new URLSearchParams(window.location.search);
                const customerId = parseInt(params.get('customerId'), 10);

                if (!customerId) {
                    this.ui.showError('有効な得意先が選択されていません。');
                    return;
                }

                const { products, departments } = await this.api.fetchMasterData();
                if (products.length === 0) {
                    this.ui.showError('指定された得意先のデータが見つかりません。');
                    return;
                }
                
                this.mutations.setInitialData(this.state, { customerId, products, departments });

                this.elements.customerNameHeader.textContent = this.state.customerName;

                this.ui.displayCustomerProducts();
                this.ui.generateInvoices();
                this.events.init();
            },

            /**
             * 頻繁に使うDOM要素をキャッシュ
             */
            cacheDOMElements() {
                for (const key in this.config.selectors) {
                    this.elements[key] = document.querySelector(this.config.selectors[key]);
                }
            },

            /**
             * 動的なスタイルを注入
             */
            injectStyles() {
                const style = document.createElement('style');
                style.textContent = `.action-button { padding: 8px 12px; border: none; color: white; border-radius: 4px; cursor: pointer; }`;
                document.head.appendChild(style);
            },

            /**
             * リンクにキャッシュ対策を追加
             */
            setupLinks() {
                if (this.elements.backLink) {
                    this.elements.backLink.href = `index.html?_=${new Date().getTime()}`;
                }
            },

            /**
             * 状態の変更をセット
             * @param {boolean} dirty - 変更があったかどうか
             */
            setDirty(dirty) {
                this.mutations.setDirty(this.state, dirty);
            },

            // --- API通信関連 ---
            api: {
                async fetchMasterData() {
                    // ★★★ 特定の得意先の商品と、全部門リストを並行して取得 ★★★
                    try {
                        const customerId = new URLSearchParams(window.location.search).get('customerId');
                        const productsUrl = `${App.config.gasWebAppUrl}?action=getProducts&customerId=${customerId}&_=${new Date().getTime()}`;
                        const departmentsUrl = `${App.config.gasWebAppUrl}?action=getDepartments&_=${new Date().getTime()}`; // ★★★ 部門リスト取得用のURLに変更

                        const [productsResponse, departmentsResponse] = await Promise.all([
                            fetch(productsUrl),
                            fetch(departmentsUrl)
                        ]);

                        if (!productsResponse.ok) throw new Error(`Products fetch failed: ${productsResponse.status}`);
                        if (!departmentsResponse.ok) throw new Error(`Departments fetch failed: ${departmentsResponse.status}`);

                        const products = await productsResponse.json();
                        const departments = await departmentsResponse.json();

                        if (products.error) throw new Error(products.error);
                        if (departments.error) throw new Error(departments.error);

                        return { products, departments };
                    } catch (error) {
                        console.error('Error fetching master data from GAS:', error);
                        return { products: [], departments: [] }; // ★★★ エラー時の戻り値を修正
                    }
                },
                async postData(payload, isAutoSave = false) {
                    const options = {
                        method: 'POST',
                        headers: { 'Content-Type': 'text/plain;charset=utf-8' },
                        body: JSON.stringify(payload)
                    };
                    // ★★★ ページ遷移時でもリクエストがキャンセルされないようにする ★★★
                    if (isAutoSave) options.keepalive = true;

                    const response = await fetch(App.config.gasWebAppUrl, options);
                    const result = await response.json();
                    if (result.status === 'error') throw new Error(result.message);
                    return result;
                }
            },

            // --- イベント関連 ---
            events: {
                // ... (変更なし)
                init() {
                    App.elements.clearButton.addEventListener('click', this.handleClearQuantities);
                    App.elements.editProductsButton.addEventListener('click', () => this.handleToggleEditMode());
                    App.elements.addProductButton.addEventListener('click', this.handleAddNewProduct);
                    App.elements.cancelEditButton.addEventListener('click', () => this.handleCancelEdit());
                    App.elements.productsTableBody.addEventListener('input', this.handleTableInput);
                    App.elements.productsTableBody.addEventListener('focusin', this.handleFocusIn);
                    App.elements.productsTableBody.addEventListener('keydown', this.handleKeyDown);
                    document.addEventListener('visibilitychange', this.handleVisibilityChange); // ★★★ 自動保存イベントを追加
                },
                // ... (以降のイベントハンドラは変更なし)

                async handleClearQuantities() {
                    // ★★★ サーバー通信を行わず、画面上の入力欄のみをクリアする ★★★
                    if (!confirm('数量をすべてクリアします。よろしいですか？')) return;

                    let hasCleared = false;
                    App.elements.productsTableBody.querySelectorAll(App.config.selectors.quantityInput).forEach(input => {
                        if (input.value !== '') {
                            input.value = '';
                            hasCleared = true;
                        }
                    });
                    
                    // 画面上の伝票を再描画
                    App.ui.generateInvoices();
                    // 変更があったことを記録（自動保存のため）
                    if (hasCleared) App.setDirty(true);
                    App.ui.showToast('画面の数量をクリアしました。');
                },

                async handleToggleEditMode() {
                    const isEditing = App.elements.productsTableBody.classList.contains(App.constants.EDIT_MODE_CLASS);
                    if (isEditing) {
                        const wasSaved = await App.events.handleSaveProducts();
                        if (wasSaved) {
                            App.setDirty(false);
                            App.ui.toggleEditMode(false);
                            App.ui.showToast('保存しました。ページを更新します...', App.settings.toastDuration);
                            setTimeout(() => window.location.reload(), App.settings.toastDuration);
                        }
                    } else {
                        App.setDirty(true);
                        App.ui.toggleEditMode(true);
                    }
                },

                async handleSaveProducts() {
                    // ★★★ データ収集ロジックをヘルパー関数に委譲 ★★★
                    const { updates, additions } = App.ui._collectSaveData({
                        collectMaster: true,
                        collectQuantity: true // ★★★ 数量の変更も一緒に保存するように修正 ★★★
                    }); // ★★★ 保存用のデータ収集関数を呼び出す

                    if (updates.length === 0 && additions.length === 0) {
                        App.ui.showToast('変更された項目はありません。');
                        return false;
                    }
                    if (!confirm(`${updates.length}件の更新、${additions.length}件の新規追加を保存します。よろしいですか？`)) return false;

                    const button = App.elements.editProductsButton;
                    App.ui.toggleButtonState(button, true, '保存中...');
                    try {
                        await App.api.postData({ updates, additions });

                        // ★★★ リロード対策: バックアップ保存 ★★★
                        const backupKey = `backup_${App.state.customerId}`;
                        sessionStorage.setItem(backupKey, JSON.stringify({
                            timestamp: Date.now(),
                            updates: updates
                        }));

                        return true;
                    } catch (error) {
                        App.ui.showToast(`保存エラー: ${error.message}`, App.settings.toastErrorDuration);
                        return false;
                    } finally {
                        App.ui.toggleButtonState(button, false, '変更を保存');
                    }
                },

                handleCancelEdit() {
                    if (confirm('編集中の内容は破棄されます。よろしいですか？')) {
                        App.ui.toggleEditMode(false);
                        App.ui.displayCustomerProducts(); // テーブルを元の状態に再描画
                        App.ui.generateInvoices(); // 伝票も再描画
                        App.setDirty(false); // 変更フラグをリセット
                        App.ui.showToast('編集をキャンセルしました。');
                    }
                },

                handleAddNewProduct() {
                    App.ui.appendNewProductRow();
                    App.setDirty(true);
                },

                handleTableInput() {
                    App.ui.generateInvoices();
                    App.setDirty(true);
                },

                handleFocusIn(e) {
                    if (e.target.classList.contains('quantity-input')) {
                        e.target.select();
                    }
                },

                handleKeyDown(e) {
                    if (e.key === 'Enter' && e.target.classList.contains('quantity-input')) {
                        e.preventDefault();
                        const allInputs = Array.from(App.elements.productsTableBody.querySelectorAll(App.config.selectors.quantityInput));
                        const currentIndex = allInputs.indexOf(e.target);
                        const nextIndex = currentIndex + 1;
                        if (nextIndex < allInputs.length) {
                            allInputs[nextIndex].focus();
                            allInputs[nextIndex].select();
                        } else {
                            e.target.blur();
                        }
                    }
                },

                handleVisibilityChange() {
                    // ページが非表示になり、かつ変更がある場合に自動保存を実行
                    if (document.visibilityState === 'hidden' && App.state.isDirty) {
                        // ★★★ データ収集ロジックをヘルパー関数に委譲 ★★★
                        const { updates } = App.ui._collectSaveData({
                            collectQuantity: true
                        }); // ★★★ 保存用のデータ収集関数を呼び出す

                        if (updates.length > 0) {
                            // ページを離れる直前のデータ送信のため、完了を待たない
                            // ★★★ 離脱対策: バックアップ保存 ★★★
                            const backupKey = `backup_${App.state.customerId}`;
                            sessionStorage.setItem(backupKey, JSON.stringify({
                                timestamp: Date.now(),
                                updates: updates
                            }));

                            try {
                                App.api.postData({ updates }, true); // ★★★ 自動保存フラグをtrueにする
                                App.setDirty(false); // 送信試行後は変更フラグをリセット
                            } catch (error) {
                                // このエラーはユーザーには通知しない（ページ離脱中のため）
                                console.error('Auto-save failed:', error);
                            }
                        }
                    }
                }
            },

            // --- UI関連 ---
            ui: {
                // ★★★ XSS対策: innerHTMLを避け、安全なDOM操作でエラーメッセージを生成 ★★★
                showError(message) {
                    const container = document.createElement('div');
                    container.className = 'container';
                    const h1 = document.createElement('h1');
                    h1.textContent = 'エラー';
                    const p = document.createElement('p');
                    p.textContent = message; // textContentを使い、スクリプトの実行を防止
                    const a = document.createElement('a');
                    a.href = 'index.html';
                    a.textContent = '得意先一覧に戻ってください。';
                    container.append(h1, p, a);
                    document.body.innerHTML = ''; // 既存のコンテンツをクリア
                    document.body.appendChild(container);
                },

                showToast(message, duration = App.settings.toastDuration) {
                    const toast = document.createElement('div');
                    toast.className = 'toast-notification';
                    toast.textContent = message;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.classList.add('show'), 100);
                    setTimeout(() => {
                        toast.classList.remove('show');
                        toast.addEventListener('transitionend', () => toast.remove());
                    }, duration);
                },

                toggleButtonState(button, isDisabled, text) {
                    button.disabled = isDisabled;
                    button.textContent = text;
                },

                toggleEditMode(isEditing) {
                    // App.elements.productsTableBody.classList.remove('is-editing'); // 既存のクラスを削除
                    
                    if (isEditing) {
                        App.elements.productsTableBody.classList.add('is-editing'); // 'is-editing' を追加
                        this.toggleButtonState(App.elements.editProductsButton, false, '変更を保存');
                        App.elements.editProductsButton.style.backgroundColor = '#16a085';
                        App.elements.addProductButton.style.display = 'inline-block';
                        App.elements.cancelEditButton.style.display = 'inline-block';
                    } else {
                        this.toggleButtonState(App.elements.editProductsButton, false, '商品を編集');
                        App.elements.editProductsButton.style.backgroundColor = '#2ecc71';
                        App.elements.productsTableBody.classList.remove('is-editing'); // 'is-editing' を削除
                        App.elements.addProductButton.style.display = 'none';
                        App.elements.cancelEditButton.style.display = 'none';
                    }
                },

                displayCustomerProducts() {
                    const { productsTableBody } = App.elements;
                    const fragment = document.createDocumentFragment(); // ★★★ 仮の置き場所を作成
                    productsTableBody.innerHTML = '';
                    if (App.state.products.length > 0) {
                        App.state.products.forEach(product => {
                            const row = this.createProductRow(product);
                            fragment.appendChild(row); // ★★★ 仮の置き場所に行を追加
                        });
                        productsTableBody.appendChild(fragment); // ★★★ 最後に一括で追加
                    } else {
                        productsTableBody.innerHTML = '<tr><td colspan="5">この得意先に登録されている商品はありません。</td></tr>';
                    }
                },

                // ★★★ 入力要素作成のヘルパー関数 ★★★
                _createInput(type, className, value, placeholder = '') {
                    const input = document.createElement('input');
                    input.type = type;
                    input.className = className;
                    if (placeholder) input.placeholder = placeholder;
                    input.value = value;
                    return input;
                },

                // ★★★ XSS対策: innerHTMLを避け、安全なDOM操作でテーブル行を生成 ★★★
                createProductRow(product) {
                    const row = document.createElement('tr');
                    row.dataset.productId = product['商品コード'];
                    const unitPrice = product['単価'] || '';
                    const sellPrice = product['売価'] || '';
                    const { CLASSES } = App.constants;

                    // 1. 商品名セル
                    const nameCell = document.createElement('td');
                    nameCell.className = CLASSES.PRODUCT_NAME_CELL;
                    const nameDisplay = document.createElement('span');
                    nameDisplay.className = `${CLASSES.DISPLAY_SPAN} name-display`;
                    nameDisplay.textContent = product['商品名']; // textContentで安全に設定
                    const nameInput = this._createInput('text', `${CLASSES.EDITABLE_INPUT} name-input`, product['商品名']);
                    nameCell.append(nameDisplay, nameInput);

                    // 2. 数量セル
                    const quantityCell = document.createElement('td');
                    const quantityInput = this._createInput('number', 'quantity-input', product['数量'] || '', '0');
                    quantityCell.appendChild(quantityInput);

                    // 3. 単価セル
                    const unitPriceCell = document.createElement('td');
                    unitPriceCell.className = CLASSES.PRICE_CELL;
                    const unitPriceDisplay = document.createElement('span');
                    unitPriceDisplay.className = `${CLASSES.DISPLAY_SPAN} unit-price-display`;
                    unitPriceDisplay.textContent = unitPrice ? unitPrice.toLocaleString() : '';
                    const unitPriceInput = this._createInput('number', `${CLASSES.EDITABLE_INPUT} unit-price-input`, unitPrice);
                    unitPriceCell.append(unitPriceDisplay, unitPriceInput);

                    // 4. 売価セル
                    const sellPriceCell = document.createElement('td');
                    sellPriceCell.className = CLASSES.PRICE_CELL;
                    const sellPriceDisplay = document.createElement('span');
                    sellPriceDisplay.className = `${CLASSES.DISPLAY_SPAN} sell-price-display`;
                    sellPriceDisplay.textContent = sellPrice ? sellPrice.toLocaleString() : '';
                    const sellPriceInput = this._createInput('number', `${CLASSES.EDITABLE_INPUT} sell-price-input`, sellPrice);
                    sellPriceCell.append(sellPriceDisplay, sellPriceInput);

                    // 5. 部門セル
                    const deptCell = document.createElement('td');
                    deptCell.className = 'col-department dept-select-container';
                    const deptDisplay = document.createElement('span');
                    deptDisplay.className = `${CLASSES.DISPLAY_SPAN} dept-display`;
                    deptDisplay.textContent = product['部門'] || ''; // textContentで安全に設定
                    const deptSelect = this._createDepartmentSelect(product['部門コード']);
                    deptCell.append(deptDisplay, deptSelect);

                    row.append(nameCell, quantityCell, unitPriceCell, sellPriceCell, deptCell);
                    return row;
                },

                _createDepartmentSelect(selectedDeptCode) {
                    const deptSelect = document.createElement('select');
                    deptSelect.className = `${App.constants.CLASSES.EDITABLE_INPUT} dept-input`;

                    const blankOption = document.createElement('option');
                    blankOption.value = '';
                    blankOption.textContent = '';
                    deptSelect.appendChild(blankOption);

                    App.state.departments.forEach(dept => {
                        const option = document.createElement('option');
                        option.value = dept.id;
                        option.textContent = dept.name;
                        if (dept.id == selectedDeptCode) {
                            option.selected = true;
                        }
                        deptSelect.appendChild(option);
                    });
                    return deptSelect;
                },

                appendNewProductRow() {
                    // ★★★ 新規行のデフォルト部門を空白にする ★★★
                    const newProduct = { '商品コード': `new_${Date.now()}`, '商品名': '', '単価': '', '売価': '', '部門コード': '' };
                    const newRow = this.createProductRow(newProduct);
                    newRow.classList.add(App.constants.NEW_PRODUCT_ROW_CLASS, App.constants.EDIT_MODE_CLASS);
                    App.elements.productsTableBody.appendChild(newRow);
                    newRow.querySelector('.name-input').focus();
                },

                generateInvoices() {
                    const allItems = this._collectDisplayItems(); // ★★★ 表示用のデータ収集関数を呼び出す
                    const groupedByDept = this.groupItemsByDepartment(allItems);
                    this.renderInvoices(groupedByDept);
                },

                // ★★★ 表示用のアイテムリストを収集する ★★★
                _collectDisplayItems() {
                    const items = [];
                    App.elements.productsTableBody.querySelectorAll('tr[data-product-id]').forEach(row => {
                        const productId = row.dataset.productId;
                        const isNew = row.classList.contains(App.constants.NEW_PRODUCT_ROW_CLASS);
                        const quantity = parseFloat(row.querySelector('.quantity-input').value);

                        if (isNew || !quantity || quantity <= 0) return;

                        const originalProduct = App.state.products.find(p => p['商品コード'] == productId);
                        if (!originalProduct) return;

                        const itemData = { ...originalProduct, quantity };

                        // 編集中の項目があれば、その値を反映する
                        const newSellPrice = row.querySelector('.sell-price-input').value;
                        if (newSellPrice !== '') itemData['売価'] = parseFloat(newSellPrice);

                        const deptSelect = row.querySelector('.dept-input');
                        if (deptSelect.value !== '') {
                            itemData['部門コード'] = deptSelect.value;
                            itemData['部門'] = deptSelect.options[deptSelect.selectedIndex].text;
                        }
                        items.push(itemData);
                    });
                    return items;
                },

                // ★★★ 保存用の更新データを収集する ★★★
                _collectSaveData(options = {}) {
                    const updates = [];
                    const additions = [];

                    App.elements.productsTableBody.querySelectorAll('tr[data-product-id]').forEach(row => {
                        const productId = row.dataset.productId;
                        const isNew = row.classList.contains(App.constants.NEW_PRODUCT_ROW_CLASS);
                        
                        if (isNew) {
                            if (options.collectMaster) { // 新規追加はマスター編集時のみ
                                const newName = row.querySelector(App.config.selectors.nameInput).value;
                                if (!newName) return;

                                const newUnitPrice = row.querySelector(App.config.selectors.unitPriceInput).value;
                                const newSellPrice = row.querySelector(App.config.selectors.sellPriceInput).value;
                                const deptSelect = row.querySelector(App.config.selectors.deptInput);
                                const newDeptCode = deptSelect.value;
                                const newDeptName = deptSelect.selectedIndex > -1 ? deptSelect.options[deptSelect.selectedIndex].text : '';

                                additions.push({
                                    '得意先コード': App.state.customerId, '得意先名': App.state.customerName, '商品名': newName,
                                    '単価': newUnitPrice !== '' ? parseFloat(newUnitPrice) : null,
                                    '売価': newSellPrice !== '' ? parseFloat(newSellPrice) : null,
                                    '部門コード': newDeptCode, '部門': newDeptName
                                });
                            }
                        } else {
                            const originalProduct = App.state.products.find(p => p['商品コード'] == productId);
                            if (!originalProduct) return;

                            // ★★★ 商品コードを数値変換せず、文字列のまま扱う（商品名ID対応） ★★★
                            const changedData = { '得意先コード': App.state.customerId, '商品コード': productId };
                            let hasChanged = false;

                            if (options.collectQuantity) {
                                // ★★★ 空文字を0として扱い、元の値と比較するロジックを修正 ★★★
                                const newQuantityValue = row.querySelector(App.config.selectors.quantityInput).value;
                                const newQuantity = newQuantityValue === '' ? 0 : parseFloat(newQuantityValue);
                                const originalQuantity = originalProduct['数量'] || 0;
                                if (newQuantity !== originalQuantity) {
                                    changedData['数量'] = newQuantity;
                                    hasChanged = true;
                                }
                            }
                            if (options.collectMaster) {
                                // ★★★ 売価が空欄にされた場合も変更として検知するように修正 ★★★
                                const newSellPriceValue = row.querySelector(App.config.selectors.sellPriceInput).value;
                                const newSellPrice = newSellPriceValue === '' ? null : parseFloat(newSellPriceValue);
                                const originalSellPrice = originalProduct['売価'] || null;
                                if (newSellPrice !== originalSellPrice) {
                                    changedData['売価'] = parseFloat(newSellPrice); hasChanged = true;
                                }
                                const deptSelect = row.querySelector(App.config.selectors.deptInput);
                                const newDeptCode = deptSelect.value;
                                const originalDeptCode = originalProduct['部門コード'] || null;
                                if (newDeptCode != (originalDeptCode ?? '')) {
                                    changedData['部門コード'] = newDeptCode;
                                    changedData['部門'] = deptSelect.options[deptSelect.selectedIndex].text;
                                    hasChanged = true;
                                }
                            }
                            if (hasChanged) updates.push(changedData);
                        }
                    });
                    return { updates, additions };
                },

                // ★★★ 現在の得意先に適用するフォーマットを取得 ★★★
                getInvoiceFormat() {
                    const { formats } = App.settings;
                    
                    // 商品データの最初の行から設定情報を取得（スプレッドシートの列を参照）
                    const settingsRow = App.state.products[0] || {};
                    
                    // 1. スプレッドシートの「フォーマット」列で指定された設定があればそれを使う
                    // 例: フォーマット列に "special" とあれば formats.special を使用
                    const formatType = settingsRow['フォーマット'];
                    if (formatType && formats[formatType]) {
                        // 設定オブジェクトをコピーして使用
                        const customFormat = { ...formats[formatType] };
                        
                        // もしスプレッドシートに「税率」列があれば、その値で上書きする (例: 0.08)
                        if (settingsRow['税率'] !== undefined && settingsRow['税率'] !== '') {
                            customFormat.taxRate = parseFloat(settingsRow['税率']);
                        }
                        // ★★★ 端数処理の設定（切り捨て/切り上げ/四捨五入） ★★★
                        if (settingsRow['端数処理']) {
                            const map = { '切り捨て': 'floor', '切り上げ': 'ceil', '四捨五入': 'round' };
                            if (map[settingsRow['端数処理']]) customFormat.taxRounding = map[settingsRow['端数処理']];
                        }
                        return customFormat;
                    }
                    
                    return formats.default;
                },

                groupItemsByDepartment(items) {
                    return items.reduce((grouped, item) => {
                        const deptId = item['部門コード'] || App.constants.UNKNOWN_DEPT_ID;
                        if (!grouped[deptId]) {
                            grouped[deptId] = { name: item['部門'], items: [] };
                        }
                        grouped[deptId].items.push(item);
                        return grouped;
                    }, {});
                },

                renderInvoices(groupedData) {
                    App.elements.invoiceContainer.innerHTML = '';
                    const invoiceFragment = document.createDocumentFragment(); // ★★★ 伝票用の仮置き場
                    const format = this.getInvoiceFormat(); // ★★★ フォーマット設定を取得

                    let grandTotalCost = 0;
                    let grandTotalSell = 0;
                    let grandTotalTax = 0; // ★★★ 消費税の総額 ★★★

                    for (const deptId in groupedData) {
                        const { totalCost, totalSell, totalTax } = this._renderDepartmentInvoice(invoiceFragment, groupedData[deptId], format);
                        grandTotalCost += totalCost;
                        grandTotalSell += totalSell;
                        grandTotalTax += totalTax;
                    }
                    if (Object.keys(groupedData).length > 0) {
                        // 表示対象の金額を選択（売価表示なしなら原価合計を使う）
                        const targetTotal = format.showSell ? grandTotalSell : grandTotalCost;
                        // ★★★ 計算済みの消費税総額を渡す ★★★
                        this._renderGrandTotal(invoiceFragment, targetTotal, format, grandTotalTax);
                    }
                    App.elements.invoiceContainer.appendChild(invoiceFragment); // ★★★ 最後に一括で伝票を描画
                },

                _renderDepartmentInvoice(fragment, deptGroup, format) {
                    const departmentHeader = document.createElement('h3');
                    departmentHeader.textContent = deptGroup.name;
                    fragment.appendChild(departmentHeader);

                    const table = document.createElement('table');
                    table.className = 'invoice-table';
                    if (!format.showSell) table.classList.add('no-sell'); // CSS用クラス

                    // ★★★ ヘッダーの動的生成 ★★★
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    headerRow.innerHTML = `<th class="invoice-col-name">品名</th><th class="invoice-col-qty">数量</th>`;
                    if (format.showCost) {
                        headerRow.innerHTML += `<th class="invoice-col-cost-price">原単価</th><th class="invoice-col-cost-sub">原価金額</th>`;
                    }
                    if (format.showSell) {
                        headerRow.innerHTML += `<th class="invoice-col-price">売単価</th><th class="invoice-col-sub">売価金額</th>`;
                    }
                    thead.appendChild(headerRow);
                    table.appendChild(thead);

                    const tbody = document.createElement('tbody');

                    let itemCounter = 0;
                    let runningSubtotal = 0;
                    let runningCostSubtotal = 0;
                    let departmentTotalCost = 0;
                    let departmentTotalSell = 0;
                    let departmentTotalTax = 0;

                    deptGroup.items.forEach((item, index) => {
                        itemCounter++;
                        const itemSubtotal = item.quantity * item['売価'];
                        const costSubtotal = item.quantity * (item['単価'] || 0);
                        runningSubtotal += itemSubtotal;
                        runningCostSubtotal += costSubtotal;
                        departmentTotalCost += costSubtotal;
                        departmentTotalSell += itemSubtotal;

                        const itemRow = this._createInvoiceItemRow(item, costSubtotal, itemSubtotal, format);
                        tbody.appendChild(itemRow);

                        const isLastItem = index === deptGroup.items.length - 1;
                        // ★★★ 設定された行数で改ページ（小計） ★★★
                        if (itemCounter % format.rowsPerPage === 0 || isLastItem) {
                            // ★★★ 小計ごとの消費税計算（端数処理設定を反映） ★★★
                            const targetSubtotal = format.showSell ? runningSubtotal : runningCostSubtotal;
                            let subtotalTax = 0;
                            if (format.showTax) {
                                subtotalTax = App.util.calculateTax(targetSubtotal, format.taxRate, format.taxRounding);
                            }
                            departmentTotalTax += subtotalTax;

                            const subtotalRow = this._createInvoiceSubtotalRow(runningCostSubtotal, runningSubtotal, format, subtotalTax);
                            tbody.appendChild(subtotalRow);
                            runningSubtotal = 0;
                            runningCostSubtotal = 0;
                        }
                    });

                    table.appendChild(tbody);
                    fragment.appendChild(table);
                    return { totalCost: departmentTotalCost, totalSell: departmentTotalSell, totalTax: departmentTotalTax };
                },

                _createInvoiceItemRow(item, costSubtotal, itemSubtotal, format) {
                    const row = document.createElement('tr');
                    const displayCost = item['単価'] ? App.util.formatNumber(item['単価']) : '';
                    const displayCostSubtotal = (item['単価'] && item['単価'] > 0) ? App.util.formatNumber(costSubtotal) : '';
                    const displaySellPrice = (item['売価'] && item['売価'] > 0) ? App.util.formatNumber(item['売価']) : '';
                    const { CLASSES } = App.constants;
                    row.appendChild(App.util.createCell(item['商品名'], CLASSES.PRODUCT_NAME_CELL)); // isHtml: false (default)
                    row.appendChild(App.util.createCell(App.util.formatNumber(item.quantity), CLASSES.PRICE_CELL, true));
                    
                    if (format.showCost) {
                        row.appendChild(App.util.createCell(displayCost, CLASSES.PRICE_CELL, true));
                        row.appendChild(App.util.createCell(displayCostSubtotal, CLASSES.COST_SUBTOTAL_CELL, true));
                    }
                    if (format.showSell) {
                        row.appendChild(App.util.createCell(displaySellPrice, CLASSES.PRICE_CELL, true));
                        row.appendChild(App.util.createCell(App.util.formatNumber(itemSubtotal), CLASSES.SUBTOTAL_CELL, true));
                    }
                    return row;
                },

                _createInvoiceSubtotalRow(costSubtotal, sellSubtotal, format, taxAmount = 0) {
                    const subtotalRow = document.createElement('tr');
                    subtotalRow.className = App.constants.CLASSES.SUBTOTAL_ROW;
                    
                    // ★★★ スタイル定義（クラスを使用） ★★★
                    const itemClass = 'subtotal-cell-item';
                    const dividerClass = 'subtotal-cell-divider';
                    const { CLASSES } = App.constants;

                    // ★★★ ラベルの生成 ★★★
                    let labelText = '合計';
                    if (format.showTax) {
                        labelText = `<div class="${itemClass} ${dividerClass}">合計</div><div class="${itemClass} ${dividerClass}">消費税</div><div class="${itemClass}">税込</div>`;
                    }
                    
                    const labelCell1 = App.util.createCell(labelText, CLASSES.TOTAL_LABEL, true);
                    
                    // colspanの計算: 品名(1) + 数量(1) + (原単価(1) if showCost)
                    let colSpan = 2;
                    if (format.showCost) colSpan += 1;
                    labelCell1.colSpan = colSpan;
                    
                    subtotalRow.appendChild(labelCell1);

                    if (format.showCost) {
                        let content = App.util.formatNumber(costSubtotal);
                        if (format.showTax && !format.showSell) { // 売価なし（原価のみ）かつ税表示ありの場合
                            content = `<div class="${itemClass} ${dividerClass}">${App.util.formatNumber(costSubtotal)}</div><div class="${itemClass} ${dividerClass}">${App.util.formatNumber(taxAmount)}</div><div class="${itemClass}">${App.util.formatNumber(costSubtotal + taxAmount)}</div>`;
                        }
                        subtotalRow.appendChild(App.util.createCell(content, CLASSES.TOTAL_VALUE, true));
                    }
                    
                    if (format.showSell) {
                        // 原価と売価の両方がある場合は間に「合計」ラベルを挟む
                        if (format.showCost) {
                            // 中央のラベルも同様にフォーマットする
                            let middleLabel = '合計';
                            if (format.showTax) {
                                middleLabel = `<div class="${itemClass} ${dividerClass}">合計</div><div class="${itemClass} ${dividerClass}">消費税</div><div class="${itemClass}">税込</div>`;
                            }
                            subtotalRow.appendChild(App.util.createCell(middleLabel, CLASSES.TOTAL_LABEL, true));
                        }
                        let content = App.util.formatNumber(sellSubtotal);
                        if (format.showTax) {
                            content = `<div class="${itemClass} ${dividerClass}">${App.util.formatNumber(sellSubtotal)}</div><div class="${itemClass} ${dividerClass}">${App.util.formatNumber(taxAmount)}</div><div class="${itemClass}">${App.util.formatNumber(sellSubtotal + taxAmount)}</div>`;
                        }
                        subtotalRow.appendChild(App.util.createCell(content, CLASSES.TOTAL_VALUE, true));
                    }
                    return subtotalRow;
                },

                _renderGrandTotal(fragment, totalAmount) {
                    const { CLASSES } = App.constants;
                    const grandTotalHeader = document.createElement('h3');
                    grandTotalHeader.textContent = '総合計';
                    grandTotalHeader.className = 'grand-total-header';
                    
                    const table = document.createElement('table');
                    const tbody = document.createElement('tbody');
                    
                    // 税抜合計
                    const totalRow = document.createElement('tr');
                    totalRow.className = CLASSES.SUBTOTAL_ROW;
                    totalRow.innerHTML = `<td class="${CLASSES.TOTAL_LABEL}" style="width: 80%;">税抜合計</td><td class="${CLASSES.TOTAL_VALUE}">${App.util.formatNumber(totalAmount)}</td>`;
                    tbody.appendChild(totalRow);

                    table.appendChild(tbody);

                    fragment.appendChild(grandTotalHeader);
                    fragment.appendChild(table);
                }
            },

            // --- ユーティリティ関数 ---
            util: {
                // ★★★ XSS対策: HTMLを意図的に挿入する場合のみisHtmlフラグをtrueにする ★★★
                createCell(content, className, isHtml = false) {
                    const cell = document.createElement('td');
                    if (isHtml) {
                        cell.innerHTML = content;
                    } else {
                        cell.textContent = content;
                    }
                    if (className) cell.className = className;
                    return cell;
                },

                formatNumber(num) {
                    if (typeof num !== 'number' || isNaN(num)) return '';
                    if (num < 0) {
                        return `<span class="minus-symbol">▲</span>${Math.abs(num).toLocaleString()}`;
                    }
                    return num.toLocaleString();
                },

                calculateTax(amount, rate, rounding) {
                    const tax = amount * rate;
                    switch (rounding) {
                        case 'ceil': return Math.ceil(tax);
                        case 'round': return Math.round(tax);
                        case 'floor': default: return Math.floor(tax);
                    }
                }
            }
        };

        document.addEventListener('DOMContentLoaded', () => App.init());
    </script>
</body>
</html>
